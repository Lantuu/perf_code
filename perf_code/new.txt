commit 1d32d4cdb84f6044496b4c1f6f9853da1369a31f
Author: Pauli Virtanen <pav@iki.fi>
Date:   Sat Oct 23 14:42:01 2010 +0000

    BUG: sparse/arpack: fix off-by-two in check for ncv

diff --git a/scipy/sparse/linalg/eigen/arpack/arpack.py b/scipy/sparse/linalg/eigen/arpack/arpack.py
index 90d0f4e58..fcbc32b76 100644
--- a/scipy/sparse/linalg/eigen/arpack/arpack.py
+++ b/scipy/sparse/linalg/eigen/arpack/arpack.py
@@ -82,9 +82,6 @@ class _ArpackParams(object):
             ncv = 2 * k + 1
         ncv = min(ncv, n)
 
-        if ncv > n or ncv < k:
-            raise ValueError("ncv must be k<=ncv<=n, ncv=%s" % ncv)
-
         self.v = np.zeros((n, ncv), tp) # holds Ritz vectors
         self.iparam = np.zeros(11, "int")
 
@@ -119,6 +116,9 @@ class _SymmetricArpackParams(_ArpackParams):
         _ArpackParams.__init__(self, n, k, tp, matvec, sigma,
                  ncv, v0, maxiter, which, tol)
 
+        if self.ncv > n or self.ncv <= k:
+            raise ValueError("ncv must be k<ncv<=n, ncv=%s" % self.ncv)
+
         self.workd = np.zeros(3 * n, self.tp)
         self.workl = np.zeros(self.ncv * (self.ncv + 8), self.tp)
 
@@ -182,6 +182,9 @@ class _UnsymmetricArpackParams(_ArpackParams):
         _ArpackParams.__init__(self, n, k, tp, matvec, sigma,
                  ncv, v0, maxiter, which, tol)
 
+        if self.ncv > n or self.ncv <= k+1:
+            raise ValueError("ncv must be k+1<ncv<=n, ncv=%s" % self.ncv)
+
         self.workd = np.zeros(3 * n, self.tp)
         self.workl = np.zeros(3 * self.ncv * self.ncv + 6 * self.ncv, self.tp)
 

commit e0b20c3585c9d667003d5e5b0283d9b5de23cb56
Author: Pauli Virtanen <pav@iki.fi>
Date:   Sat Oct 23 14:41:16 2010 +0000

    BUG: sparse/arpack: fix ARPACK overwriting the initial vector (#1313)

diff --git a/scipy/sparse/linalg/eigen/arpack/arpack.py b/scipy/sparse/linalg/eigen/arpack/arpack.py
index 62e4583d6..90d0f4e58 100644
--- a/scipy/sparse/linalg/eigen/arpack/arpack.py
+++ b/scipy/sparse/linalg/eigen/arpack/arpack.py
@@ -68,7 +68,8 @@ class _ArpackParams(object):
             raise ValueError("matrix type must be 'f', 'd', 'F', or 'D'")
 
         if v0 is not None:
-            self.resid = v0
+            # ARPACK overwrites its initial resid,  make a copy
+            self.resid = np.array(v0, copy=True)
             info = 1
         else:
             self.resid = np.zeros(n, tp)

commit 718e8395e7095cd4cc2382ae12ad1d40b73bc006
Author: warren.weckesser <warren.weckesser@localhost>
Date:   Sat Sep 18 04:58:40 2010 +0000

    BUG: sparse: Incorrect formatting in the eigen() function of arpack.py resulted in a TypeError instead of a ValueError when a matrix with an invalid shape was given.

diff --git a/scipy/sparse/linalg/eigen/arpack/arpack.py b/scipy/sparse/linalg/eigen/arpack/arpack.py
index 8a0ed3d3f..62e4583d6 100644
--- a/scipy/sparse/linalg/eigen/arpack/arpack.py
+++ b/scipy/sparse/linalg/eigen/arpack/arpack.py
@@ -383,7 +383,7 @@ def eigen(A, k=6, M=None, sigma=None, which='LM', v0=None,
     """
     A = aslinearoperator(A)
     if A.shape[0] != A.shape[1]:
-        raise ValueError('expected square matrix (shape=%s)' % A.shape)
+        raise ValueError('expected square matrix (shape=%s)' % (A.shape,))
     n = A.shape[0]
 
     matvec = lambda x : A.matvec(x)
@@ -476,7 +476,7 @@ def eigen_symmetric(A, k=6, M=None, sigma=None, which='LM', v0=None,
     """
     A = aslinearoperator(A)
     if A.shape[0] != A.shape[1]:
-        raise ValueError('expected square matrix (shape=%s)' % shape)
+        raise ValueError('expected square matrix (shape=%s)' % (A.shape,))
     n = A.shape[0]
 
     if M is not None:
@@ -513,7 +513,7 @@ def svd(A, k=6):
     n, m = A.shape
 
     if np.iscomplexobj(A):
-        raise NotImplementedError("Complex support for sparse SVD not " \
+        raise NotImplementedError("Complex support for sparse SVD not "
                                   "implemented yet")
         op = lambda x: x.T.conjugate()
     else:

commit b063bc18e7f8795209c2f662029a15a48e8d4e34
Author: David Cournapeau <cournape@gmail.com>
Date:   Fri Mar 26 05:35:35 2010 +0000

    ENH: use implicit A'A computation for sparse SVD.

diff --git a/scipy/sparse/linalg/eigen/arpack/arpack.py b/scipy/sparse/linalg/eigen/arpack/arpack.py
index 4ea33654f..8a0ed3d3f 100644
--- a/scipy/sparse/linalg/eigen/arpack/arpack.py
+++ b/scipy/sparse/linalg/eigen/arpack/arpack.py
@@ -519,22 +519,35 @@ def svd(A, k=6):
     else:
         op = lambda x: x.T
 
-    def _left(x):
+    tp = A.dtype.char
+    linear_at = aslinearoperator(op(A))
+    linear_a = aslinearoperator(A)
+
+    def _left(x, sz):
         x = csc_matrix(x)
-        m = op(x) * x
 
-        eigvals, eigvec = eigen_symmetric(m, k)
+        matvec = lambda x: linear_at.matvec(linear_a.matvec(x))
+        params = _SymmetricArpackParams(sz, k, tp, matvec)
+
+        while not params.converged:
+            params.iterate()
+        eigvals, eigvec = params.extract(True)
         s = np.sqrt(eigvals)
 
         v = eigvec
         u = (x * v) / s
         return u, s, op(v)
 
-    def _right(x):
+    def _right(x, sz):
         x = csr_matrix(x)
-        m = x * op(x)
 
-        eigvals, eigvec = eigen_symmetric(m, k)
+        matvec = lambda x: linear_a.matvec(linear_at.matvec(x))
+        params = _SymmetricArpackParams(sz, k, tp, matvec)
+
+        while not params.converged:
+            params.iterate()
+        eigvals, eigvec = params.extract(True)
+
         s = np.sqrt(eigvals)
 
         u = eigvec
@@ -542,6 +555,6 @@ def svd(A, k=6):
         return u, s, vh
 
     if n > m:
-        return _left(A)
+        return _left(A, m)
     else:
-        return _right(A)
+        return _right(A, n)

commit 37985216492404f37d1d0008ed4e7e0e5b1ee250
Author: David Cournapeau <cournape@gmail.com>
Date:   Fri Mar 26 05:35:25 2010 +0000

    REF: abstract eigen value/vector extraction into *Params classes.

diff --git a/scipy/sparse/linalg/eigen/arpack/arpack.py b/scipy/sparse/linalg/eigen/arpack/arpack.py
index 19a31ba65..4ea33654f 100644
--- a/scipy/sparse/linalg/eigen/arpack/arpack.py
+++ b/scipy/sparse/linalg/eigen/arpack/arpack.py
@@ -123,7 +123,7 @@ class _SymmetricArpackParams(_ArpackParams):
 
         ltr = _type_conv[self.tp]
         self._arpack_solver = _arpack.__dict__[ltr + 'saupd']
-        self.extract = _arpack.__dict__[ltr + 'seupd']
+        self._arpack_extract = _arpack.__dict__[ltr + 'seupd']
 
         self.ipntr = np.zeros(11, "int")
 
@@ -152,6 +152,26 @@ class _SymmetricArpackParams(_ArpackParams):
             if self.iparam[4] < self.k:
                 warnings.warn("Only %d/%d eigenvectors converged" % (self.iparam[4], self.k))
 
+    def extract(self, return_eigenvectors):
+        rvec = return_eigenvectors
+        ierr = 0
+        howmny = 'A' # return all eigenvectors
+        sselect = np.zeros(self.ncv, 'int') # unused
+        sigma = 0.0 # no shifts, not implemented
+
+        d, z, info = self._arpack_extract(rvec, howmny, sselect, sigma, self.bmat,
+                self.which, self.k, self.tol, self.resid, self.v,
+                self.iparam[0:7], self.ipntr, self.workd[0:2*self.n],
+                self.workl,ierr)
+
+        if ierr != 0:
+            raise RuntimeError("Error info=%d in arpack" % params.info)
+
+        if return_eigenvectors:
+            return d, z
+        else:
+            return d
+
 class _UnsymmetricArpackParams(_ArpackParams):
     def __init__(self, n, k, tp, matvec, sigma=None,
                  ncv=None, v0=None, maxiter=None, which="LM", tol=0):
@@ -166,7 +186,7 @@ class _UnsymmetricArpackParams(_ArpackParams):
 
         ltr = _type_conv[self.tp]
         self._arpack_solver = _arpack.__dict__[ltr + 'naupd']
-        self.extract = _arpack.__dict__[ltr + 'neupd']
+        self._arpack_extract = _arpack.__dict__[ltr + 'neupd']
 
         self.ipntr = np.zeros(14, "int")
 
@@ -203,6 +223,88 @@ class _UnsymmetricArpackParams(_ArpackParams):
             elif self.info == -1:
                 warnings.warn("Maximum number of iterations taken: %s" % self.iparam[2])
 
+    def extract(self, return_eigenvectors):
+        k, n = self.k, self.n
+
+        ierr = 0
+        howmny = 'A' # return all eigenvectors
+        sselect = np.zeros(self.ncv, 'int') # unused
+        sigmai = 0.0 # no shifts, not implemented
+        sigmar = 0.0 # no shifts, not implemented
+        workev = np.zeros(3 * self.ncv, self.tp)
+
+        if self.tp in 'fd':
+            dr = np.zeros(k+1, self.tp)
+            di = np.zeros(k+1, self.tp)
+            zr = np.zeros((n, k+1), self.tp)
+            dr, di, zr, self.info=\
+                self._arpack_extract(return_eigenvectors,
+                       howmny, sselect, sigmar, sigmai, workev,
+                       self.bmat, self.which, k, self.tol, self.resid,
+                       self.v, self.iparam, self.ipntr,
+                       self.workd, self.workl, self.info)
+
+            # The ARPACK nonsymmetric real and double interface (s,d)naupd return
+            # eigenvalues and eigenvectors in real (float,double) arrays.
+
+            # Build complex eigenvalues from real and imaginary parts
+            d = dr + 1.0j * di
+
+            # Arrange the eigenvectors: complex eigenvectors are stored as
+            # real,imaginary in consecutive columns
+            z = zr.astype(self.tp.upper())
+            eps = np.finfo(self.tp).eps
+            i = 0
+            while i<=k:
+                # check if complex
+                if abs(d[i].imag) > eps:
+                    # assume this is a complex conjugate pair with eigenvalues
+                    # in consecutive columns
+                    z[:,i] = zr[:,i] + 1.0j * zr[:,i+1]
+                    z[:,i+1] = z[:,i].conjugate()
+                    i +=1
+                i += 1
+
+            # Now we have k+1 possible eigenvalues and eigenvectors
+            # Return the ones specified by the keyword "which"
+            nreturned = self.iparam[4] # number of good eigenvalues returned
+            if nreturned == k:    # we got exactly how many eigenvalues we wanted
+                d = d[:k]
+                z = z[:,:k]
+            else:   # we got one extra eigenvalue (likely a cc pair, but which?)
+                # cut at approx precision for sorting
+                rd = np.round(d, decimals = _ndigits[self.tp])
+                if self.which in ['LR','SR']:
+                    ind = np.argsort(rd.real)
+                elif self.which in ['LI','SI']:
+                    # for LI,SI ARPACK returns largest,smallest abs(imaginary) why?
+                    ind = np.argsort(abs(rd.imag))
+                else:
+                    ind = np.argsort(abs(rd))
+                if self.which in ['LR','LM','LI']:
+                    d = d[ind[-k:]]
+                    z = z[:,ind[-k:]]
+                if self.which in ['SR','SM','SI']:
+                    d = d[ind[:k]]
+                    z = z[:,ind[:k]]
+
+        else:
+            # complex is so much simpler...
+            d, z, self.info =\
+                    self._arpack_extract(return_eigenvectors,
+                           howmny, sselect, sigmar, workev,
+                           self.bmat, self.which, k, self.tol, self.resid,
+                           self.v, self.iparam, self.ipntr,
+                           self.workd, self.workl, self.rwork, ierr)
+
+        if ierr != 0:
+            raise RuntimeError("Error info=%d in arpack" % info)
+
+        if return_eigenvectors:
+            return d, z
+        else:
+            return d
+
 def eigen(A, k=6, M=None, sigma=None, which='LM', v0=None,
           ncv=None, maxiter=None, tol=0,
           return_eigenvectors=True):
@@ -294,87 +396,7 @@ def eigen(A, k=6, M=None, sigma=None, which='LM', v0=None,
     while not params.converged:
         params.iterate()
 
-    # now extract eigenvalues and (optionally) eigenvectors
-    rvec = return_eigenvectors
-    ierr = 0
-    howmny = 'A' # return all eigenvectors
-    sselect = np.zeros(params.ncv, 'int') # unused
-    sigmai = 0.0 # no shifts, not implemented
-    sigmar = 0.0 # no shifts, not implemented
-    workev = np.zeros(3 * params.ncv, params.tp)
-
-    if params.tp in 'fd':
-        dr = np.zeros(k+1, params.tp)
-        di = np.zeros(k+1, params.tp)
-        zr = np.zeros((n, k+1), params.tp)
-        dr, di, zr, params.info=\
-            params.extract(rvec, howmny, sselect, sigmar, sigmai, workev,
-                   params.bmat, params.which, k, params.tol, params.resid,
-                   params.v, params.iparam, params.ipntr,
-                   params.workd, params.workl, params.info)
-
-        # The ARPACK nonsymmetric real and double interface (s,d)naupd return
-        # eigenvalues and eigenvectors in real (float,double) arrays.
-
-        # Build complex eigenvalues from real and imaginary parts
-        d = dr + 1.0j * di
-
-        # Arrange the eigenvectors: complex eigenvectors are stored as
-        # real,imaginary in consecutive columns
-        z = zr.astype(params.tp.upper())
-        eps = np.finfo(params.tp).eps
-        i = 0
-        while i<=k:
-            # check if complex
-            if abs(d[i].imag) > eps:
-                # assume this is a complex conjugate pair with eigenvalues
-                # in consecutive columns
-                z[:,i] = zr[:,i] + 1.0j * zr[:,i+1]
-                z[:,i+1] = z[:,i].conjugate()
-                i +=1
-            i += 1
-
-        # Now we have k+1 possible eigenvalues and eigenvectors
-        # Return the ones specified by the keyword "which"
-        nreturned = params.iparam[4] # number of good eigenvalues returned
-        if nreturned == k:    # we got exactly how many eigenvalues we wanted
-            d = d[:k]
-            z = z[:,:k]
-        else:   # we got one extra eigenvalue (likely a cc pair, but which?)
-            # cut at approx precision for sorting
-            rd = np.round(d, decimals = _ndigits[params.tp])
-            if params.which in ['LR','SR']:
-                ind = np.argsort(rd.real)
-            elif which in ['LI','SI']:
-                # for LI,SI ARPACK returns largest,smallest abs(imaginary) why?
-                ind = np.argsort(abs(rd.imag))
-            else:
-                ind = np.argsort(abs(rd))
-            if params.which in ['LR','LM','LI']:
-                d = d[ind[-k:]]
-                z = z[:,ind[-k:]]
-            if params.which in ['SR','SM','SI']:
-                d = d[ind[:k]]
-                z = z[:,ind[:k]]
-
-
-    else:
-        # complex is so much simpler...
-        d, z, params.info =\
-                params.extract(rvec, howmny, sselect, sigmar, workev,
-                       params.bmat, params.which, k, params.tol, params.resid,
-                       params.v, params.iparam, params.ipntr,
-                       params.workd, params.workl, params.rwork, ierr)
-
-
-
-    if ierr != 0:
-        raise RuntimeError("Error info=%d in arpack"%info)
-        return None
-    if return_eigenvectors:
-        return d,z
-    return d
-
+    return params.extract(return_eigenvectors)
 
 def eigen_symmetric(A, k=6, M=None, sigma=None, which='LM', v0=None,
                     ncv=None, maxiter=None, tol=0,
@@ -467,23 +489,7 @@ def eigen_symmetric(A, k=6, M=None, sigma=None, which='LM', v0=None,
     while not params.converged:
         params.iterate()
 
-    # now extract eigenvalues and (optionally) eigenvectors
-    rvec = return_eigenvectors
-    ierr = 0
-    howmny = 'A' # return all eigenvectors
-    sselect = np.zeros(params.ncv, 'int') # unused
-    sigma = 0.0 # no shifts, not implemented
-
-    d, z, info = params.extract(rvec, howmny, sselect, sigma, params.bmat,
-            params.which, k, params.tol, params.resid, params.v,
-            params.iparam[0:7], params.ipntr, params.workd[0:2*n],
-            params.workl,ierr)
-
-    if ierr != 0:
-        raise RuntimeError("Error info=%d in arpack" % params.info)
-    if return_eigenvectors:
-        return d, z
-    return d
+    return params.extract(return_eigenvectors)
 
 def svd(A, k=6):
     """Compute a few singular values/vectors for a sparse matrix using ARPACK.

commit 4122cf9532f93e59a16afa3404ba58561ebba4fd
Author: David Cournapeau <cournape@gmail.com>
Date:   Fri Mar 26 05:35:16 2010 +0000

    REF: split symmetric/unsymmetric cases in two classes.

diff --git a/scipy/sparse/linalg/eigen/arpack/arpack.py b/scipy/sparse/linalg/eigen/arpack/arpack.py
index d2eb91034..19a31ba65 100644
--- a/scipy/sparse/linalg/eigen/arpack/arpack.py
+++ b/scipy/sparse/linalg/eigen/arpack/arpack.py
@@ -52,7 +52,7 @@ _type_conv = {'f':'s', 'd':'d', 'F':'c', 'D':'z'}
 _ndigits = {'f':5, 'd':12, 'F':5, 'D':12}
 
 class _ArpackParams(object):
-    def __init__(self, n, k, tp, matvec, mode="symmetric", sigma=None,
+    def __init__(self, n, k, tp, matvec, sigma=None,
                  ncv=None, v0=None, maxiter=None, which="LM", tol=0):
         if k <= 0:
             raise ValueError("k must be positive, k=%d" % k)
@@ -84,39 +84,7 @@ class _ArpackParams(object):
         if ncv > n or ncv < k:
             raise ValueError("ncv must be k<=ncv<=n, ncv=%s" % ncv)
 
-        ltr = _type_conv[tp]
-
         self.v = np.zeros((n, ncv), tp) # holds Ritz vectors
-        self.rwork = None # Only used for unsymmetric, complex solver
-
-        if mode == "unsymmetric":
-            if not which in ["LM", "SM", "LR", "SR", "LI", "SI"]:
-                raise ValueError("Parameter which must be one of %s" % ' '.join(whiches))
-
-            self.workd = np.zeros(3 * n, tp)
-            self.workl = np.zeros(3 * ncv * ncv + 6 * ncv, tp)
-            self._arpack_solver = _arpack.__dict__[ltr + 'naupd']
-            self.iterate = self._unsymmetric_solver
-            self.extract = _arpack.__dict__[ltr + 'neupd']
-
-            if tp in 'FD':
-                self.rwork = np.zeros(ncv, tp.lower())
-
-            self.ipntr = np.zeros(14, "int")
-        elif mode == "symmetric":
-            if not which in ['LM','SM','LA','SA','BE']:
-                raise ValueError("which must be one of %s" % ' '.join(whiches))
-
-            self.workd = np.zeros(3 * n, tp)
-            self.workl = np.zeros(ncv * (ncv + 8), tp)
-            self._arpack_solver = _arpack.__dict__[ltr + 'saupd']
-            self.iterate = self._symmetric_solver
-            self.extract = _arpack.__dict__[ltr + 'seupd']
-
-            self.ipntr = np.zeros(11, "int")
-        else:
-            raise ValueError("Unrecognized mode %s" % mode)
-
         self.iparam = np.zeros(11, "int")
 
         # set solver mode and parameters
@@ -128,7 +96,6 @@ class _ArpackParams(object):
         self.iparam[6] = mode1
 
         self.n = n
-        self.mode = mode
         self.matvec = matvec
         self.tol = tol
         self.k = k
@@ -142,17 +109,29 @@ class _ArpackParams(object):
         self.converged = False
         self.ido = 0
 
-    def _unsymmetric_solver(self):
-        if self.tp in 'fd':
-            self.ido, self.resid, self.v, self.iparam, self.ipntr, self.info = \
-                self._arpack_solver(self.ido, self.bmat, self.which, self.k, self.tol,
-                        self.resid, self.v, self.iparam, self.ipntr,
-                        self.workd, self.workl, self.info)
-        else:
-            self.ido, self.resid, self.v, self.iparam, self.ipntr, self.info =\
-                self._arpack_solver(self.ido, self.bmat, self.which, self.k, self.tol,
-                        self.resid, self.v, self.iparam, self.ipntr,
-                        self.workd, self.workl, self.rwork, self.info)
+class _SymmetricArpackParams(_ArpackParams):
+    def __init__(self, n, k, tp, matvec, sigma=None,
+                 ncv=None, v0=None, maxiter=None, which="LM", tol=0):
+        if not which in ['LM', 'SM', 'LA', 'SA', 'BE']:
+            raise ValueError("which must be one of %s" % ' '.join(whiches))
+
+        _ArpackParams.__init__(self, n, k, tp, matvec, sigma,
+                 ncv, v0, maxiter, which, tol)
+
+        self.workd = np.zeros(3 * n, self.tp)
+        self.workl = np.zeros(self.ncv * (self.ncv + 8), self.tp)
+
+        ltr = _type_conv[self.tp]
+        self._arpack_solver = _arpack.__dict__[ltr + 'saupd']
+        self.extract = _arpack.__dict__[ltr + 'seupd']
+
+        self.ipntr = np.zeros(11, "int")
+
+    def iterate(self):
+        self.ido, self.resid, self.v, self.iparam, self.ipntr, self.info = \
+            self._arpack_solver(self.ido, self.bmat, self.which, self.k, self.tol,
+                    self.resid, self.v, self.iparam, self.ipntr,
+                    self.workd, self.workl, self.info)
 
         xslice = slice(self.ipntr[0]-1, self.ipntr[0]-1+self.n)
         yslice = slice(self.ipntr[1]-1, self.ipntr[1]-1+self.n)
@@ -170,11 +149,43 @@ class _ArpackParams(object):
             elif self.info == -1:
                 warnings.warn("Maximum number of iterations taken: %s" % self.iparam[2])
 
-    def _symmetric_solver(self):
-        self.ido, self.resid, self.v, self.iparam, self.ipntr, self.info = \
-            self._arpack_solver(self.ido, self.bmat, self.which, self.k, self.tol,
-                    self.resid, self.v, self.iparam, self.ipntr,
-                    self.workd, self.workl, self.info)
+            if self.iparam[4] < self.k:
+                warnings.warn("Only %d/%d eigenvectors converged" % (self.iparam[4], self.k))
+
+class _UnsymmetricArpackParams(_ArpackParams):
+    def __init__(self, n, k, tp, matvec, sigma=None,
+                 ncv=None, v0=None, maxiter=None, which="LM", tol=0):
+        if not which in ["LM", "SM", "LR", "SR", "LI", "SI"]:
+            raise ValueError("Parameter which must be one of %s" % ' '.join(whiches))
+
+        _ArpackParams.__init__(self, n, k, tp, matvec, sigma,
+                 ncv, v0, maxiter, which, tol)
+
+        self.workd = np.zeros(3 * n, self.tp)
+        self.workl = np.zeros(3 * self.ncv * self.ncv + 6 * self.ncv, self.tp)
+
+        ltr = _type_conv[self.tp]
+        self._arpack_solver = _arpack.__dict__[ltr + 'naupd']
+        self.extract = _arpack.__dict__[ltr + 'neupd']
+
+        self.ipntr = np.zeros(14, "int")
+
+        if self.tp in 'FD':
+            self.rwork = np.zeros(self.ncv, self.tp.lower())
+        else:
+            self.rwork = None
+
+    def iterate(self):
+        if self.tp in 'fd':
+            self.ido, self.resid, self.v, self.iparam, self.ipntr, self.info = \
+                self._arpack_solver(self.ido, self.bmat, self.which, self.k, self.tol,
+                        self.resid, self.v, self.iparam, self.ipntr,
+                        self.workd, self.workl, self.info)
+        else:
+            self.ido, self.resid, self.v, self.iparam, self.ipntr, self.info =\
+                self._arpack_solver(self.ido, self.bmat, self.which, self.k, self.tol,
+                        self.resid, self.v, self.iparam, self.ipntr,
+                        self.workd, self.workl, self.rwork, self.info)
 
         xslice = slice(self.ipntr[0]-1, self.ipntr[0]-1+self.n)
         yslice = slice(self.ipntr[1]-1, self.ipntr[1]-1+self.n)
@@ -192,9 +203,6 @@ class _ArpackParams(object):
             elif self.info == -1:
                 warnings.warn("Maximum number of iterations taken: %s" % self.iparam[2])
 
-            if self.iparam[4] < self.k:
-                warnings.warn("Only %d/%d eigenvectors converged" % (self.iparam[4], self.k))
-
 def eigen(A, k=6, M=None, sigma=None, which='LM', v0=None,
           ncv=None, maxiter=None, tol=0,
           return_eigenvectors=True):
@@ -277,7 +285,7 @@ def eigen(A, k=6, M=None, sigma=None, which='LM', v0=None,
     n = A.shape[0]
 
     matvec = lambda x : A.matvec(x)
-    params = _ArpackParams(n, k, A.dtype.char, matvec, "unsymmetric", sigma,
+    params = _UnsymmetricArpackParams(n, k, A.dtype.char, matvec, sigma,
                            ncv, v0, maxiter, which, tol)
 
     if M is not None:
@@ -453,7 +461,7 @@ def eigen_symmetric(A, k=6, M=None, sigma=None, which='LM', v0=None,
         raise NotImplementedError("generalized eigenproblem not supported yet")
 
     matvec = lambda x : A.matvec(x)
-    params = _ArpackParams(n, k, A.dtype.char, matvec, "symmetric", sigma,
+    params = _SymmetricArpackParams(n, k, A.dtype.char, matvec, sigma,
                            ncv, v0, maxiter, which, tol)
 
     while not params.converged:

commit c806aec7ff3f2076cde996016ca4175d4113cbad
Author: David Cournapeau <cournape@gmail.com>
Date:   Fri Mar 26 05:35:07 2010 +0000

    REF: abstrace solver call for ARPACK.

diff --git a/scipy/sparse/linalg/eigen/arpack/arpack.py b/scipy/sparse/linalg/eigen/arpack/arpack.py
index dd0d63cf2..d2eb91034 100644
--- a/scipy/sparse/linalg/eigen/arpack/arpack.py
+++ b/scipy/sparse/linalg/eigen/arpack/arpack.py
@@ -52,7 +52,7 @@ _type_conv = {'f':'s', 'd':'d', 'F':'c', 'D':'z'}
 _ndigits = {'f':5, 'd':12, 'F':5, 'D':12}
 
 class _ArpackParams(object):
-    def __init__(self, n, k, tp, mode="symmetric", sigma=None,
+    def __init__(self, n, k, tp, matvec, mode="symmetric", sigma=None,
                  ncv=None, v0=None, maxiter=None, which="LM", tol=0):
         if k <= 0:
             raise ValueError("k must be positive, k=%d" % k)
@@ -95,7 +95,8 @@ class _ArpackParams(object):
 
             self.workd = np.zeros(3 * n, tp)
             self.workl = np.zeros(3 * ncv * ncv + 6 * ncv, tp)
-            self.solver = _arpack.__dict__[ltr + 'naupd']
+            self._arpack_solver = _arpack.__dict__[ltr + 'naupd']
+            self.iterate = self._unsymmetric_solver
             self.extract = _arpack.__dict__[ltr + 'neupd']
 
             if tp in 'FD':
@@ -108,7 +109,8 @@ class _ArpackParams(object):
 
             self.workd = np.zeros(3 * n, tp)
             self.workl = np.zeros(ncv * (ncv + 8), tp)
-            self.solver = _arpack.__dict__[ltr + 'saupd']
+            self._arpack_solver = _arpack.__dict__[ltr + 'saupd']
+            self.iterate = self._symmetric_solver
             self.extract = _arpack.__dict__[ltr + 'seupd']
 
             self.ipntr = np.zeros(11, "int")
@@ -127,6 +129,7 @@ class _ArpackParams(object):
 
         self.n = n
         self.mode = mode
+        self.matvec = matvec
         self.tol = tol
         self.k = k
         self.maxiter = maxiter
@@ -136,6 +139,62 @@ class _ArpackParams(object):
         self.info = info
         self.bmat = 'I'
 
+        self.converged = False
+        self.ido = 0
+
+    def _unsymmetric_solver(self):
+        if self.tp in 'fd':
+            self.ido, self.resid, self.v, self.iparam, self.ipntr, self.info = \
+                self._arpack_solver(self.ido, self.bmat, self.which, self.k, self.tol,
+                        self.resid, self.v, self.iparam, self.ipntr,
+                        self.workd, self.workl, self.info)
+        else:
+            self.ido, self.resid, self.v, self.iparam, self.ipntr, self.info =\
+                self._arpack_solver(self.ido, self.bmat, self.which, self.k, self.tol,
+                        self.resid, self.v, self.iparam, self.ipntr,
+                        self.workd, self.workl, self.rwork, self.info)
+
+        xslice = slice(self.ipntr[0]-1, self.ipntr[0]-1+self.n)
+        yslice = slice(self.ipntr[1]-1, self.ipntr[1]-1+self.n)
+        if self.ido == -1:
+            # initialization
+            self.workd[yslice] = self.matvec(self.workd[xslice])
+        elif self.ido == 1:
+            # compute y=Ax
+            self.workd[yslice] = self.matvec(self.workd[xslice])
+        else:
+            self.converged = True
+
+            if self.info < -1 :
+                raise RuntimeError("Error info=%d in arpack" % self.info)
+            elif self.info == -1:
+                warnings.warn("Maximum number of iterations taken: %s" % self.iparam[2])
+
+    def _symmetric_solver(self):
+        self.ido, self.resid, self.v, self.iparam, self.ipntr, self.info = \
+            self._arpack_solver(self.ido, self.bmat, self.which, self.k, self.tol,
+                    self.resid, self.v, self.iparam, self.ipntr,
+                    self.workd, self.workl, self.info)
+
+        xslice = slice(self.ipntr[0]-1, self.ipntr[0]-1+self.n)
+        yslice = slice(self.ipntr[1]-1, self.ipntr[1]-1+self.n)
+        if self.ido == -1:
+            # initialization
+            self.workd[yslice] = self.matvec(self.workd[xslice])
+        elif self.ido == 1:
+            # compute y=Ax
+            self.workd[yslice] = self.matvec(self.workd[xslice])
+        else:
+            self.converged = True
+
+            if self.info < -1 :
+                raise RuntimeError("Error info=%d in arpack" % self.info)
+            elif self.info == -1:
+                warnings.warn("Maximum number of iterations taken: %s" % self.iparam[2])
+
+            if self.iparam[4] < self.k:
+                warnings.warn("Only %d/%d eigenvectors converged" % (self.iparam[4], self.k))
+
 def eigen(A, k=6, M=None, sigma=None, which='LM', v0=None,
           ncv=None, maxiter=None, tol=0,
           return_eigenvectors=True):
@@ -217,41 +276,15 @@ def eigen(A, k=6, M=None, sigma=None, which='LM', v0=None,
         raise ValueError('expected square matrix (shape=%s)' % A.shape)
     n = A.shape[0]
 
-    params = _ArpackParams(n, k, A.dtype.char, "unsymmetric", sigma,
+    matvec = lambda x : A.matvec(x)
+    params = _ArpackParams(n, k, A.dtype.char, matvec, "unsymmetric", sigma,
                            ncv, v0, maxiter, which, tol)
 
     if M is not None:
         raise NotImplementedError("generalized eigenproblem not supported yet")
 
-    ido = 0
-
-    while True:
-        if params.tp in 'fd':
-            ido, params.resid, params.v, params.iparam, params.ipntr, params.info = \
-                params.solver(ido, params.bmat, params.which, params.k, params.tol,
-                        params.resid, params.v, params.iparam, params.ipntr,
-                        params.workd, params.workl, params.info)
-        else:
-            ido, params.resid, params.v, params.iparam, params.ipntr, params.info =\
-                params.solver(ido, params.bmat, params.which, params.k, params.tol,
-                        params.resid, params.v, params.iparam, params.ipntr,
-                        params.workd, params.workl, params.rwork, params.info)
-
-        xslice = slice(params.ipntr[0]-1, params.ipntr[0]-1+n)
-        yslice = slice(params.ipntr[1]-1, params.ipntr[1]-1+n)
-        if ido == -1:
-            # initialization
-            params.workd[yslice] = A.matvec(params.workd[xslice])
-        elif ido == 1:
-            # compute y=Ax
-            params.workd[yslice] = A.matvec(params.workd[xslice])
-        else:
-            break
-
-    if params.info < -1 :
-        raise RuntimeError("Error info=%d in arpack" % params.info)
-    elif params.info == -1:
-        warnings.warn("Maximum number of iterations taken: %s" % self.iparam[2])
+    while not params.converged:
+        params.iterate()
 
     # now extract eigenvalues and (optionally) eigenvectors
     rvec = return_eigenvectors
@@ -419,34 +452,12 @@ def eigen_symmetric(A, k=6, M=None, sigma=None, which='LM', v0=None,
     if M is not None:
         raise NotImplementedError("generalized eigenproblem not supported yet")
 
-    params = _ArpackParams(n, k, A.dtype.char, "symmetric", sigma,
+    matvec = lambda x : A.matvec(x)
+    params = _ArpackParams(n, k, A.dtype.char, matvec, "symmetric", sigma,
                            ncv, v0, maxiter, which, tol)
 
-    ido = 0
-    while True:
-        ido, params.resid, params.v, params.iparam, params.ipntr, params.info = \
-            params.solver(ido, params.bmat, params.which, params.k, params.tol,
-                    params.resid, params.v, params.iparam, params.ipntr,
-                    params.workd, params.workl, params.info)
-
-        xslice = slice(params.ipntr[0]-1, params.ipntr[0]-1+n)
-        yslice = slice(params.ipntr[1]-1, params.ipntr[1]-1+n)
-        if ido == -1:
-            # initialization
-            params.workd[yslice] = A.matvec(params.workd[xslice])
-        elif ido == 1:
-            # compute y=Ax
-            params.workd[yslice] = A.matvec(params.workd[xslice])
-        else:
-            break
-
-    if params.info < -1 :
-        raise RuntimeError("Error info=%d in arpack" % params.info)
-    elif params.info == 1:
-        warnings.warn("Maximum number of iterations taken: %s" % params.iparam[2])
-
-    if params.iparam[4] < k:
-        warnings.warn("Only %d/%d eigenvectors converged" % (params.iparam[4], k))
+    while not params.converged:
+        params.iterate()
 
     # now extract eigenvalues and (optionally) eigenvectors
     rvec = return_eigenvectors

commit eebbe2f546bef15c83540bb135bfa7c205d5cec8
Author: David Cournapeau <cournape@gmail.com>
Date:   Fri Mar 26 05:34:57 2010 +0000

    REF: use _ArpackParams in symmetric solver.

diff --git a/scipy/sparse/linalg/eigen/arpack/arpack.py b/scipy/sparse/linalg/eigen/arpack/arpack.py
index bbc5effd3..dd0d63cf2 100644
--- a/scipy/sparse/linalg/eigen/arpack/arpack.py
+++ b/scipy/sparse/linalg/eigen/arpack/arpack.py
@@ -84,15 +84,15 @@ class _ArpackParams(object):
         if ncv > n or ncv < k:
             raise ValueError("ncv must be k<=ncv<=n, ncv=%s" % ncv)
 
-        if not which in ["LM", "SM", "LR", "SR", "LI", "SI"]:
-            raise ValueError("Parameter which must be one of %s" % ' '.join(whiches))
-
         ltr = _type_conv[tp]
 
         self.v = np.zeros((n, ncv), tp) # holds Ritz vectors
         self.rwork = None # Only used for unsymmetric, complex solver
 
         if mode == "unsymmetric":
+            if not which in ["LM", "SM", "LR", "SR", "LI", "SI"]:
+                raise ValueError("Parameter which must be one of %s" % ' '.join(whiches))
+
             self.workd = np.zeros(3 * n, tp)
             self.workl = np.zeros(3 * ncv * ncv + 6 * ncv, tp)
             self.solver = _arpack.__dict__[ltr + 'naupd']
@@ -103,6 +103,9 @@ class _ArpackParams(object):
 
             self.ipntr = np.zeros(14, "int")
         elif mode == "symmetric":
+            if not which in ['LM','SM','LA','SA','BE']:
+                raise ValueError("which must be one of %s" % ' '.join(whiches))
+
             self.workd = np.zeros(3 * n, tp)
             self.workl = np.zeros(ncv * (ncv + 8), tp)
             self.solver = _arpack.__dict__[ltr + 'saupd']
@@ -413,107 +416,54 @@ def eigen_symmetric(A, k=6, M=None, sigma=None, which='LM', v0=None,
         raise ValueError('expected square matrix (shape=%s)' % shape)
     n = A.shape[0]
 
-    # guess type
-    typ = A.dtype.char
-    if typ not in 'fd':
-        raise ValueError("matrix must be real valued (type must be 'f' or 'd')")
-
     if M is not None:
         raise NotImplementedError("generalized eigenproblem not supported yet")
-    if sigma is not None:
-        raise NotImplementedError("shifted eigenproblem not supported yet")
-
-    if ncv is None:
-        ncv=2*k+1
-    ncv=min(ncv,n)
-    if maxiter==None:
-        maxiter=n*10
-    # assign starting vector
-    if v0 is not None:
-        resid=v0
-        info=1
-    else:
-        resid = np.zeros(n,typ)
-        info=0
-
-    # some sanity checks
-    if k <= 0:
-        raise ValueError("k must be positive, k=%d"%k)
-    if k == n:
-        raise ValueError("k must be less than rank(A), k=%d"%k)
-    if maxiter <= 0:
-        raise ValueError("maxiter must be positive, maxiter=%d"%maxiter)
-    whiches=['LM','SM','LA','SA','BE']
-    if which not in whiches:
-        raise ValueError("which must be one of %s"%' '.join(whiches))
-    if ncv > n or ncv < k:
-        raise ValueError("ncv must be k<=ncv<=n, ncv=%s"%ncv)
-
-    # assign solver and postprocessor
-    ltr = _type_conv[typ]
-    eigsolver = _arpack.__dict__[ltr+'saupd']
-    eigextract = _arpack.__dict__[ltr+'seupd']
-
-    # set output arrays, parameters, and workspace
-    v = np.zeros((n,ncv),typ)
-    workd = np.zeros(3*n,typ)
-    workl = np.zeros(ncv*(ncv+8),typ)
-    iparam = np.zeros(11,'int')
-    ipntr = np.zeros(11,'int')
-    ido = 0
 
-    # set solver mode and parameters
-    # only supported mode is 1: Ax=lx
-    ishfts = 1
-    mode1 = 1
-    bmat='I'
-    iparam[0] = ishfts
-    iparam[2] = maxiter
-    iparam[6] = mode1
+    params = _ArpackParams(n, k, A.dtype.char, "symmetric", sigma,
+                           ncv, v0, maxiter, which, tol)
 
+    ido = 0
     while True:
-        ido,resid,v,iparam,ipntr,info =\
-            eigsolver(ido,bmat,which,k,tol,resid,v,
-                      iparam,ipntr,workd,workl,info)
+        ido, params.resid, params.v, params.iparam, params.ipntr, params.info = \
+            params.solver(ido, params.bmat, params.which, params.k, params.tol,
+                    params.resid, params.v, params.iparam, params.ipntr,
+                    params.workd, params.workl, params.info)
 
-        xslice = slice(ipntr[0]-1, ipntr[0]-1+n)
-        yslice = slice(ipntr[1]-1, ipntr[1]-1+n)
+        xslice = slice(params.ipntr[0]-1, params.ipntr[0]-1+n)
+        yslice = slice(params.ipntr[1]-1, params.ipntr[1]-1+n)
         if ido == -1:
             # initialization
-            workd[yslice]=A.matvec(workd[xslice])
+            params.workd[yslice] = A.matvec(params.workd[xslice])
         elif ido == 1:
             # compute y=Ax
-            workd[yslice]=A.matvec(workd[xslice])
+            params.workd[yslice] = A.matvec(params.workd[xslice])
         else:
             break
 
-    if info < -1 :
-        raise RuntimeError("Error info=%d in arpack" % info)
-        return None
-
-    if info == 1:
-        warnings.warn("Maximum number of iterations taken: %s" % iparam[2])
+    if params.info < -1 :
+        raise RuntimeError("Error info=%d in arpack" % params.info)
+    elif params.info == 1:
+        warnings.warn("Maximum number of iterations taken: %s" % params.iparam[2])
 
-    if iparam[4] < k:
-        warnings.warn("Only %d/%d eigenvectors converged" % (iparam[4], k))
+    if params.iparam[4] < k:
+        warnings.warn("Only %d/%d eigenvectors converged" % (params.iparam[4], k))
 
     # now extract eigenvalues and (optionally) eigenvectors
     rvec = return_eigenvectors
     ierr = 0
     howmny = 'A' # return all eigenvectors
-    sselect = np.zeros(ncv,'int') # unused
+    sselect = np.zeros(params.ncv, 'int') # unused
     sigma = 0.0 # no shifts, not implemented
 
-    d,z,info =\
-             eigextract(rvec,howmny,sselect,sigma,
-                        bmat,which, k,tol,resid,v,iparam[0:7],ipntr,
-                        workd[0:2*n],workl,ierr)
+    d, z, info = params.extract(rvec, howmny, sselect, sigma, params.bmat,
+            params.which, k, params.tol, params.resid, params.v,
+            params.iparam[0:7], params.ipntr, params.workd[0:2*n],
+            params.workl,ierr)
 
     if ierr != 0:
-        raise RuntimeError("Error info=%d in arpack"%info)
-        return None
+        raise RuntimeError("Error info=%d in arpack" % params.info)
     if return_eigenvectors:
-        return d,z
+        return d, z
     return d
 
 def svd(A, k=6):

commit 1fb8c5bb71d6b5b16083a296dcc71a91b877659c
Author: David Cournapeau <cournape@gmail.com>
Date:   Fri Mar 26 05:34:48 2010 +0000

    REF: put arpack unsymmetric solver paramaters checking into separate object.

diff --git a/scipy/sparse/linalg/eigen/arpack/arpack.py b/scipy/sparse/linalg/eigen/arpack/arpack.py
index 88e17643c..bbc5effd3 100644
--- a/scipy/sparse/linalg/eigen/arpack/arpack.py
+++ b/scipy/sparse/linalg/eigen/arpack/arpack.py
@@ -51,6 +51,87 @@ from scipy.sparse import csc_matrix, csr_matrix
 _type_conv = {'f':'s', 'd':'d', 'F':'c', 'D':'z'}
 _ndigits = {'f':5, 'd':12, 'F':5, 'D':12}
 
+class _ArpackParams(object):
+    def __init__(self, n, k, tp, mode="symmetric", sigma=None,
+                 ncv=None, v0=None, maxiter=None, which="LM", tol=0):
+        if k <= 0:
+            raise ValueError("k must be positive, k=%d" % k)
+        if k == n:
+            raise ValueError("k must be less than rank(A), k=%d" % k)
+
+        if maxiter is None:
+            maxiter = n * 10
+        if maxiter <= 0:
+            raise ValueError("maxiter must be positive, maxiter=%d" % maxiter)
+
+        if tp not in 'fdFD':
+            raise ValueError("matrix type must be 'f', 'd', 'F', or 'D'")
+
+        if v0 is not None:
+            self.resid = v0
+            info = 1
+        else:
+            self.resid = np.zeros(n, tp)
+            info = 0
+
+        if sigma is not None:
+            raise NotImplementedError("shifted eigenproblem not supported yet")
+
+        if ncv is None:
+            ncv = 2 * k + 1
+        ncv = min(ncv, n)
+
+        if ncv > n or ncv < k:
+            raise ValueError("ncv must be k<=ncv<=n, ncv=%s" % ncv)
+
+        if not which in ["LM", "SM", "LR", "SR", "LI", "SI"]:
+            raise ValueError("Parameter which must be one of %s" % ' '.join(whiches))
+
+        ltr = _type_conv[tp]
+
+        self.v = np.zeros((n, ncv), tp) # holds Ritz vectors
+        self.rwork = None # Only used for unsymmetric, complex solver
+
+        if mode == "unsymmetric":
+            self.workd = np.zeros(3 * n, tp)
+            self.workl = np.zeros(3 * ncv * ncv + 6 * ncv, tp)
+            self.solver = _arpack.__dict__[ltr + 'naupd']
+            self.extract = _arpack.__dict__[ltr + 'neupd']
+
+            if tp in 'FD':
+                self.rwork = np.zeros(ncv, tp.lower())
+
+            self.ipntr = np.zeros(14, "int")
+        elif mode == "symmetric":
+            self.workd = np.zeros(3 * n, tp)
+            self.workl = np.zeros(ncv * (ncv + 8), tp)
+            self.solver = _arpack.__dict__[ltr + 'saupd']
+            self.extract = _arpack.__dict__[ltr + 'seupd']
+
+            self.ipntr = np.zeros(11, "int")
+        else:
+            raise ValueError("Unrecognized mode %s" % mode)
+
+        self.iparam = np.zeros(11, "int")
+
+        # set solver mode and parameters
+        # only supported mode is 1: Ax=lx
+        ishfts = 1
+        mode1 = 1
+        self.iparam[0] = ishfts
+        self.iparam[2] = maxiter
+        self.iparam[6] = mode1
+
+        self.n = n
+        self.mode = mode
+        self.tol = tol
+        self.k = k
+        self.maxiter = maxiter
+        self.ncv = ncv
+        self.which = which
+        self.tp = tp
+        self.info = info
+        self.bmat = 'I'
 
 def eigen(A, k=6, M=None, sigma=None, which='LM', v0=None,
           ncv=None, maxiter=None, tol=0,
@@ -133,168 +214,113 @@ def eigen(A, k=6, M=None, sigma=None, which='LM', v0=None,
         raise ValueError('expected square matrix (shape=%s)' % A.shape)
     n = A.shape[0]
 
-    # guess type
-    typ = A.dtype.char
-    if typ not in 'fdFD':
-        raise ValueError("matrix type must be 'f', 'd', 'F', or 'D'")
+    params = _ArpackParams(n, k, A.dtype.char, "unsymmetric", sigma,
+                           ncv, v0, maxiter, which, tol)
 
     if M is not None:
         raise NotImplementedError("generalized eigenproblem not supported yet")
-    if sigma is not None:
-        raise NotImplementedError("shifted eigenproblem not supported yet")
 
-
-    # some defaults
-    if ncv is None:
-        ncv=2*k+1
-    ncv=min(ncv,n)
-    if maxiter==None:
-        maxiter=n*10
-    # assign starting vector
-    if v0 is not None:
-        resid=v0
-        info=1
-    else:
-        resid = np.zeros(n,typ)
-        info=0
-
-
-    # some sanity checks
-    if k <= 0:
-        raise ValueError("k must be positive, k=%d"%k)
-    if k == n:
-        raise ValueError("k must be less than rank(A), k=%d"%k)
-    if maxiter <= 0:
-        raise ValueError("maxiter must be positive, maxiter=%d"%maxiter)
-    whiches=['LM','SM','LR','SR','LI','SI']
-    if which not in whiches:
-        raise ValueError("which must be one of %s"%' '.join(whiches))
-    if ncv > n or ncv < k:
-        raise ValueError("ncv must be k<=ncv<=n, ncv=%s"%ncv)
-
-    # assign solver and postprocessor
-    ltr = _type_conv[typ]
-    eigsolver = _arpack.__dict__[ltr+'naupd']
-    eigextract = _arpack.__dict__[ltr+'neupd']
-
-    v = np.zeros((n,ncv),typ) # holds Ritz vectors
-    workd = np.zeros(3*n,typ) # workspace
-    workl = np.zeros(3*ncv*ncv+6*ncv,typ) # workspace
-    iparam = np.zeros(11,'int') # problem parameters
-    ipntr = np.zeros(14,'int') # pointers into workspaces
     ido = 0
 
-    if typ in 'FD':
-        rwork = np.zeros(ncv,typ.lower())
-
-    # set solver mode and parameters
-    # only supported mode is 1: Ax=lx
-    ishfts = 1
-    mode1 = 1
-    bmat = 'I'
-    iparam[0] = ishfts
-    iparam[2] = maxiter
-    iparam[6] = mode1
-
     while True:
-        if typ in 'fd':
-            ido,resid,v,iparam,ipntr,info =\
-                eigsolver(ido,bmat,which,k,tol,resid,v,iparam,ipntr,
-                          workd,workl,info)
+        if params.tp in 'fd':
+            ido, params.resid, params.v, params.iparam, params.ipntr, params.info = \
+                params.solver(ido, params.bmat, params.which, params.k, params.tol,
+                        params.resid, params.v, params.iparam, params.ipntr,
+                        params.workd, params.workl, params.info)
         else:
-            ido,resid,v,iparam,ipntr,info =\
-                eigsolver(ido,bmat,which,k,tol,resid,v,iparam,ipntr,
-                          workd,workl,rwork,info)
+            ido, params.resid, params.v, params.iparam, params.ipntr, params.info =\
+                params.solver(ido, params.bmat, params.which, params.k, params.tol,
+                        params.resid, params.v, params.iparam, params.ipntr,
+                        params.workd, params.workl, params.rwork, params.info)
 
-        xslice = slice(ipntr[0]-1, ipntr[0]-1+n)
-        yslice = slice(ipntr[1]-1, ipntr[1]-1+n)
+        xslice = slice(params.ipntr[0]-1, params.ipntr[0]-1+n)
+        yslice = slice(params.ipntr[1]-1, params.ipntr[1]-1+n)
         if ido == -1:
             # initialization
-            workd[yslice]=A.matvec(workd[xslice])
+            params.workd[yslice] = A.matvec(params.workd[xslice])
         elif ido == 1:
             # compute y=Ax
-            workd[yslice]=A.matvec(workd[xslice])
+            params.workd[yslice] = A.matvec(params.workd[xslice])
         else:
             break
 
-    if  info < -1 :
-        raise RuntimeError("Error info=%d in arpack"%info)
-        return None
-    if info == -1:
-        warnings.warn("Maximum number of iterations taken: %s"%iparam[2])
-#    if iparam[3] != k:
-#        warnings.warn("Only %s eigenvalues converged"%iparam[3])
-
+    if params.info < -1 :
+        raise RuntimeError("Error info=%d in arpack" % params.info)
+    elif params.info == -1:
+        warnings.warn("Maximum number of iterations taken: %s" % self.iparam[2])
 
     # now extract eigenvalues and (optionally) eigenvectors
     rvec = return_eigenvectors
     ierr = 0
     howmny = 'A' # return all eigenvectors
-    sselect = np.zeros(ncv,'int') # unused
+    sselect = np.zeros(params.ncv, 'int') # unused
     sigmai = 0.0 # no shifts, not implemented
     sigmar = 0.0 # no shifts, not implemented
-    workev = np.zeros(3*ncv,typ)
-
-    if typ in 'fd':
-        dr=np.zeros(k+1,typ)
-        di=np.zeros(k+1,typ)
-        zr=np.zeros((n,k+1),typ)
-        dr,di,zr,info=\
-            eigextract(rvec,howmny,sselect,sigmar,sigmai,workev,
-                   bmat,which,k,tol,resid,v,iparam,ipntr,
-                   workd,workl,info)
+    workev = np.zeros(3 * params.ncv, params.tp)
+
+    if params.tp in 'fd':
+        dr = np.zeros(k+1, params.tp)
+        di = np.zeros(k+1, params.tp)
+        zr = np.zeros((n, k+1), params.tp)
+        dr, di, zr, params.info=\
+            params.extract(rvec, howmny, sselect, sigmar, sigmai, workev,
+                   params.bmat, params.which, k, params.tol, params.resid,
+                   params.v, params.iparam, params.ipntr,
+                   params.workd, params.workl, params.info)
 
         # The ARPACK nonsymmetric real and double interface (s,d)naupd return
         # eigenvalues and eigenvectors in real (float,double) arrays.
 
         # Build complex eigenvalues from real and imaginary parts
-        d=dr+1.0j*di
+        d = dr + 1.0j * di
 
         # Arrange the eigenvectors: complex eigenvectors are stored as
         # real,imaginary in consecutive columns
-        z=zr.astype(typ.upper())
-        eps=np.finfo(typ).eps
-        i=0
+        z = zr.astype(params.tp.upper())
+        eps = np.finfo(params.tp).eps
+        i = 0
         while i<=k:
             # check if complex
-            if abs(d[i].imag)>eps:
+            if abs(d[i].imag) > eps:
                 # assume this is a complex conjugate pair with eigenvalues
                 # in consecutive columns
-                z[:,i]=zr[:,i]+1.0j*zr[:,i+1]
-                z[:,i+1]=z[:,i].conjugate()
-                i+=1
-            i+=1
+                z[:,i] = zr[:,i] + 1.0j * zr[:,i+1]
+                z[:,i+1] = z[:,i].conjugate()
+                i +=1
+            i += 1
 
         # Now we have k+1 possible eigenvalues and eigenvectors
         # Return the ones specified by the keyword "which"
-        nreturned=iparam[4] # number of good eigenvalues returned
-        if nreturned==k:    # we got exactly how many eigenvalues we wanted
-            d=d[:k]
-            z=z[:,:k]
+        nreturned = params.iparam[4] # number of good eigenvalues returned
+        if nreturned == k:    # we got exactly how many eigenvalues we wanted
+            d = d[:k]
+            z = z[:,:k]
         else:   # we got one extra eigenvalue (likely a cc pair, but which?)
             # cut at approx precision for sorting
-            rd=np.round(d,decimals=_ndigits[typ])
-            if which in ['LR','SR']:
-                ind=np.argsort(rd.real)
+            rd = np.round(d, decimals = _ndigits[params.tp])
+            if params.which in ['LR','SR']:
+                ind = np.argsort(rd.real)
             elif which in ['LI','SI']:
                 # for LI,SI ARPACK returns largest,smallest abs(imaginary) why?
-                ind=np.argsort(abs(rd.imag))
+                ind = np.argsort(abs(rd.imag))
             else:
-                ind=np.argsort(abs(rd))
-            if which in ['LR','LM','LI']:
-                d=d[ind[-k:]]
-                z=z[:,ind[-k:]]
-            if which in ['SR','SM','SI']:
-                d=d[ind[:k]]
-                z=z[:,ind[:k]]
+                ind = np.argsort(abs(rd))
+            if params.which in ['LR','LM','LI']:
+                d = d[ind[-k:]]
+                z = z[:,ind[-k:]]
+            if params.which in ['SR','SM','SI']:
+                d = d[ind[:k]]
+                z = z[:,ind[:k]]
 
 
     else:
         # complex is so much simpler...
-        d,z,info =\
-              eigextract(rvec,howmny,sselect,sigmar,workev,
-                         bmat,which,k,tol,resid,v,iparam,ipntr,
-                         workd,workl,rwork,ierr)
+        d, z, params.info =\
+                params.extract(rvec, howmny, sselect, sigmar, workev,
+                       params.bmat, params.which, k, params.tol, params.resid,
+                       params.v, params.iparam, params.ipntr,
+                       params.workd, params.workl, params.rwork, ierr)
 
 
 

commit 307a4dbbc5ca402086f65f366b21b5c87a641e8e
Author: David Cournapeau <cournape@gmail.com>
Date:   Mon Feb 22 09:02:18 2010 +0000

    ENH: implement naive SVD for sparse real matrices.

diff --git a/scipy/sparse/linalg/eigen/arpack/arpack.py b/scipy/sparse/linalg/eigen/arpack/arpack.py
index fb19142f1..88e17643c 100644
--- a/scipy/sparse/linalg/eigen/arpack/arpack.py
+++ b/scipy/sparse/linalg/eigen/arpack/arpack.py
@@ -39,13 +39,14 @@ Uses ARPACK: http://www.caam.rice.edu/software/ARPACK/
 
 __docformat__ = "restructuredtext en"
 
-__all___=['eigen','eigen_symmetric']
+__all___=['eigen','eigen_symmetric', 'svd']
 
 import warnings
 
 import _arpack
 import numpy as np
 from scipy.sparse.linalg.interface import aslinearoperator
+from scipy.sparse import csc_matrix, csr_matrix
 
 _type_conv = {'f':'s', 'd':'d', 'F':'c', 'D':'z'}
 _ndigits = {'f':5, 'd':12, 'F':5, 'D':12}
@@ -488,3 +489,58 @@ def eigen_symmetric(A, k=6, M=None, sigma=None, which='LM', v0=None,
     if return_eigenvectors:
         return d,z
     return d
+
+def svd(A, k=6):
+    """Compute a few singular values/vectors for a sparse matrix using ARPACK.
+
+    Parameters
+    ----------
+    A: sparse matrix
+        Array to compute the SVD on.
+    k: int
+        Number of singular values and vectors to compute.
+
+    Note
+    ----
+    This is a naive implementation using the symmetric eigensolver on A.T * A
+    or A * A.T, depending on which one is more efficient.
+
+    Complex support is not implemented yet
+    """
+    # TODO: implement complex support once ARPACK-based eigen_hermitian is
+    # available
+    n, m = A.shape
+
+    if np.iscomplexobj(A):
+        raise NotImplementedError("Complex support for sparse SVD not " \
+                                  "implemented yet")
+        op = lambda x: x.T.conjugate()
+    else:
+        op = lambda x: x.T
+
+    def _left(x):
+        x = csc_matrix(x)
+        m = op(x) * x
+
+        eigvals, eigvec = eigen_symmetric(m, k)
+        s = np.sqrt(eigvals)
+
+        v = eigvec
+        u = (x * v) / s
+        return u, s, op(v)
+
+    def _right(x):
+        x = csr_matrix(x)
+        m = x * op(x)
+
+        eigvals, eigvec = eigen_symmetric(m, k)
+        s = np.sqrt(eigvals)
+
+        u = eigvec
+        vh = (op(u) * x) / s[:, None]
+        return u, s, vh
+
+    if n > m:
+        return _left(A)
+    else:
+        return _right(A)

commit edd7be0c8ae924207495bd66276af7859a123eed
Author: David Cournapeau <cournape@gmail.com>
Date:   Fri Feb 5 04:31:54 2010 +0000

    BUG: fix error message for non-square input to arpack.eigen.

diff --git a/scipy/sparse/linalg/eigen/arpack/arpack.py b/scipy/sparse/linalg/eigen/arpack/arpack.py
index 043e0a743..fb19142f1 100644
--- a/scipy/sparse/linalg/eigen/arpack/arpack.py
+++ b/scipy/sparse/linalg/eigen/arpack/arpack.py
@@ -129,7 +129,7 @@ def eigen(A, k=6, M=None, sigma=None, which='LM', v0=None,
     """
     A = aslinearoperator(A)
     if A.shape[0] != A.shape[1]:
-        raise ValueError('expected square matrix (shape=%s)' % shape)
+        raise ValueError('expected square matrix (shape=%s)' % A.shape)
     n = A.shape[0]
 
     # guess type

commit 6bb62d5d6003e3887f739b3eb6d7d761d5023c68
Author: wnbell <wnbell@localhost>
Date:   Thu Jun 12 21:39:52 2008 +0000

    fixed bug reported by James Philbin
    http://thread.gmane.org/gmane.comp.python.scientific.user/16720

diff --git a/scipy/sparse/linalg/eigen/arpack/arpack.py b/scipy/sparse/linalg/eigen/arpack/arpack.py
index e1268c535..043e0a743 100644
--- a/scipy/sparse/linalg/eigen/arpack/arpack.py
+++ b/scipy/sparse/linalg/eigen/arpack/arpack.py
@@ -460,11 +460,15 @@ def eigen_symmetric(A, k=6, M=None, sigma=None, which='LM', v0=None,
         else:
             break
 
-    if  info < -1 :
-        raise RuntimeError("Error info=%d in arpack"%info)
+    if info < -1 :
+        raise RuntimeError("Error info=%d in arpack" % info)
         return None
-    if info == -1:
-        warnings.warn("Maximum number of iterations taken: %s"%iparam[2])
+
+    if info == 1:
+        warnings.warn("Maximum number of iterations taken: %s" % iparam[2])
+
+    if iparam[4] < k:
+        warnings.warn("Only %d/%d eigenvectors converged" % (iparam[4], k))
 
     # now extract eigenvalues and (optionally) eigenvectors
     rvec = return_eigenvectors

commit f78bec961c8a33744a1edc28e5f1d7ad489b09b4
Author: wnbell <wnbell@localhost>
Date:   Fri Jun 6 06:54:44 2008 +0000

    renamed lobpcg parameters to better conform to other iterative methods

diff --git a/scipy/sparse/linalg/eigen/arpack/arpack.py b/scipy/sparse/linalg/eigen/arpack/arpack.py
index 585d13c8e..e1268c535 100644
--- a/scipy/sparse/linalg/eigen/arpack/arpack.py
+++ b/scipy/sparse/linalg/eigen/arpack/arpack.py
@@ -62,7 +62,7 @@ def eigen(A, k=6, M=None, sigma=None, which='LM', v0=None,
 
     Parameters
     ----------
-    A : A : matrix, array, or object with matvec(x) method
+    A : matrix, array, or object with matvec(x) method
         An N x N matrix, array, or an object with matvec(x) method to perform
         the matrix vector product A * x.  The sparse matrix formats
         in scipy.sparse are appropriate for A.
@@ -76,8 +76,8 @@ def eigen(A, k=6, M=None, sigma=None, which='LM', v0=None,
         Array of k eigenvalues
 
     v : array
-       An array of k eigenvectors
-       The v[i] is the eigenvector corresponding to the eigenvector w[i]
+        An array of k eigenvectors
+        The v[i] is the eigenvector corresponding to the eigenvector w[i]
 
     Other Parameters
     ----------------

commit e835bd3c4f9c25c0e0b205fa8338523d1db47678
Author: Jarrod Millman <millman@berkeley.edu>
Date:   Sun Apr 20 12:15:19 2008 +0000

    ran reindent

diff --git a/scipy/sparse/linalg/eigen/arpack/arpack.py b/scipy/sparse/linalg/eigen/arpack/arpack.py
index facbdf61e..585d13c8e 100644
--- a/scipy/sparse/linalg/eigen/arpack/arpack.py
+++ b/scipy/sparse/linalg/eigen/arpack/arpack.py
@@ -9,26 +9,26 @@ Uses ARPACK: http://www.caam.rice.edu/software/ARPACK/
 #
 # ARPACK Entry Points
 # -------------------
-# The entry points to ARPACK are 
+# The entry points to ARPACK are
 # - (s,d)seupd : single and double precision symmetric matrix
 # - (s,d,c,z)neupd: single,double,complex,double complex general matrix
-# This wrapper puts the *neupd (general matrix) interfaces in eigen() 
-# and the *seupd (symmetric matrix) in eigen_symmetric().  
+# This wrapper puts the *neupd (general matrix) interfaces in eigen()
+# and the *seupd (symmetric matrix) in eigen_symmetric().
 # There is no Hermetian complex/double complex interface.
 # To find eigenvalues of a Hermetian matrix you
 # must use eigen() and not eigen_symmetric()
 # It might be desirable to handle the Hermetian case differently
-# and, for example, return real eigenvalues. 
+# and, for example, return real eigenvalues.
 
 # Number of eigenvalues returned and complex eigenvalues
 # ------------------------------------------------------
 # The ARPACK nonsymmetric real and double interface (s,d)naupd return
-# eigenvalues and eigenvectors in real (float,double) arrays.  
+# eigenvalues and eigenvectors in real (float,double) arrays.
 # Since the eigenvalues and eigenvectors are, in general, complex
 # ARPACK puts the real and imaginary parts in consecutive entries
 # in real-valued arrays.   This wrapper puts the real entries
 # into complex data types and attempts to return the requested eigenvalues
-# and eigenvectors.  
+# and eigenvectors.
 
 
 # Solver modes
@@ -52,7 +52,7 @@ _ndigits = {'f':5, 'd':12, 'F':5, 'D':12}
 
 
 def eigen(A, k=6, M=None, sigma=None, which='LM', v0=None,
-          ncv=None, maxiter=None, tol=0, 
+          ncv=None, maxiter=None, tol=0,
           return_eigenvectors=True):
     """Find k eigenvalues and eigenvectors of the square matrix A.
 
@@ -76,7 +76,7 @@ def eigen(A, k=6, M=None, sigma=None, which='LM', v0=None,
         Array of k eigenvalues
 
     v : array
-       An array of k eigenvectors 
+       An array of k eigenvectors
        The v[i] is the eigenvector corresponding to the eigenvector w[i]
 
     Other Parameters
@@ -92,10 +92,10 @@ def eigen(A, k=6, M=None, sigma=None, which='LM', v0=None,
         Find eigenvalues near sigma.  Shift spectrum by sigma.
 
     v0 : array
-        Starting vector for iteration.  
+        Starting vector for iteration.
 
     ncv : integer
-        The number of Lanczos vectors generated 
+        The number of Lanczos vectors generated
         ncv must be greater than k; it is recommended that ncv > 2*k
 
     which : string
@@ -107,7 +107,7 @@ def eigen(A, k=6, M=None, sigma=None, which='LM', v0=None,
          - 'LI' : largest imaginary part
          - 'SI' : smallest imaginary part
 
-    maxiter : integer 
+    maxiter : integer
         Maximum number of Arnoldi update iterations allowed
 
     tol : float
@@ -117,7 +117,7 @@ def eigen(A, k=6, M=None, sigma=None, which='LM', v0=None,
         Return eigenvectors (True) in addition to eigenvalues
 
     See Also
-    --------    
+    --------
     eigen_symmetric : eigenvalues and eigenvectors for symmetric matrix A
 
     Notes
@@ -149,7 +149,7 @@ def eigen(A, k=6, M=None, sigma=None, which='LM', v0=None,
     ncv=min(ncv,n)
     if maxiter==None:
         maxiter=n*10
-    # assign starting vector        
+    # assign starting vector
     if v0 is not None:
         resid=v0
         info=1
@@ -244,12 +244,12 @@ def eigen(A, k=6, M=None, sigma=None, which='LM', v0=None,
                    workd,workl,info)
 
         # The ARPACK nonsymmetric real and double interface (s,d)naupd return
-        # eigenvalues and eigenvectors in real (float,double) arrays.  
+        # eigenvalues and eigenvectors in real (float,double) arrays.
 
         # Build complex eigenvalues from real and imaginary parts
         d=dr+1.0j*di
 
-        # Arrange the eigenvectors: complex eigenvectors are stored as 
+        # Arrange the eigenvectors: complex eigenvectors are stored as
         # real,imaginary in consecutive columns
         z=zr.astype(typ.upper())
         eps=np.finfo(typ).eps
@@ -263,7 +263,7 @@ def eigen(A, k=6, M=None, sigma=None, which='LM', v0=None,
                 z[:,i+1]=z[:,i].conjugate()
                 i+=1
             i+=1
-                      
+
         # Now we have k+1 possible eigenvalues and eigenvectors
         # Return the ones specified by the keyword "which"
         nreturned=iparam[4] # number of good eigenvalues returned
@@ -274,10 +274,10 @@ def eigen(A, k=6, M=None, sigma=None, which='LM', v0=None,
             # cut at approx precision for sorting
             rd=np.round(d,decimals=_ndigits[typ])
             if which in ['LR','SR']:
-                ind=np.argsort(rd.real) 
+                ind=np.argsort(rd.real)
             elif which in ['LI','SI']:
                 # for LI,SI ARPACK returns largest,smallest abs(imaginary) why?
-                ind=np.argsort(abs(rd.imag)) 
+                ind=np.argsort(abs(rd.imag))
             else:
                 ind=np.argsort(abs(rd))
             if which in ['LR','LM','LI']:
@@ -306,9 +306,9 @@ def eigen(A, k=6, M=None, sigma=None, which='LM', v0=None,
 
 
 def eigen_symmetric(A, k=6, M=None, sigma=None, which='LM', v0=None,
-                    ncv=None, maxiter=None, tol=0, 
+                    ncv=None, maxiter=None, tol=0,
                     return_eigenvectors=True):
-    """Find k eigenvalues and eigenvectors of the real symmetric 
+    """Find k eigenvalues and eigenvectors of the real symmetric
     square matrix A.
 
     Solves A * x[i] = w[i] * x[i], the standard eigenvalue problem for
@@ -331,7 +331,7 @@ def eigen_symmetric(A, k=6, M=None, sigma=None, which='LM', v0=None,
         Array of k eigenvalues
 
     v : array
-       An array of k eigenvectors 
+       An array of k eigenvectors
        The v[i] is the eigenvector corresponding to the eigenvector w[i]
 
     Other Parameters
@@ -345,12 +345,12 @@ def eigen_symmetric(A, k=6, M=None, sigma=None, which='LM', v0=None,
     sigma : real
         (Not implemented)
         Find eigenvalues near sigma.  Shift spectrum by sigma.
-    
+
     v0 : array
-        Starting vector for iteration.  
+        Starting vector for iteration.
 
     ncv : integer
-        The number of Lanczos vectors generated 
+        The number of Lanczos vectors generated
         ncv must be greater than k; it is recommended that ncv > 2*k
 
     which : string
@@ -359,10 +359,10 @@ def eigen_symmetric(A, k=6, M=None, sigma=None, which='LM', v0=None,
          - 'SA' : Smallest (algebraic) eigenvalues
          - 'LM' : Largest (in magnitude) eigenvalues
          - 'SM' : Smallest (in magnitude) eigenvalues
-         - 'BE' : Half (k/2) from each end of the spectrum  
+         - 'BE' : Half (k/2) from each end of the spectrum
                   When k is odd, return one more (k/2+1) from the high end
 
-    maxiter : integer 
+    maxiter : integer
         Maximum number of Arnoldi update iterations allowed
 
     tol : float
@@ -372,7 +372,7 @@ def eigen_symmetric(A, k=6, M=None, sigma=None, which='LM', v0=None,
         Return eigenvectors (True) in addition to eigenvalues
 
     See Also
-    --------    
+    --------
     eigen : eigenvalues and eigenvectors for a general (nonsymmetric) matrix A
 
     Notes
@@ -401,7 +401,7 @@ def eigen_symmetric(A, k=6, M=None, sigma=None, which='LM', v0=None,
     ncv=min(ncv,n)
     if maxiter==None:
         maxiter=n*10
-    # assign starting vector        
+    # assign starting vector
     if v0 is not None:
         resid=v0
         info=1

commit 3ed8ef195bc8c8c2314c4954666ca64387d0fb3b
Author: Stefan van der Walt <stefan@sun.ac.za>
Date:   Wed Mar 12 08:57:03 2008 +0000

    Do not force eigen return type to be a matrix.

diff --git a/scipy/sparse/linalg/eigen/arpack/arpack.py b/scipy/sparse/linalg/eigen/arpack/arpack.py
index d227b8197..facbdf61e 100644
--- a/scipy/sparse/linalg/eigen/arpack/arpack.py
+++ b/scipy/sparse/linalg/eigen/arpack/arpack.py
@@ -301,7 +301,7 @@ def eigen(A, k=6, M=None, sigma=None, which='LM', v0=None,
         raise RuntimeError("Error info=%d in arpack"%info)
         return None
     if return_eigenvectors:
-        return d,np.asmatrix(z)
+        return d,z
     return d
 
 
@@ -482,5 +482,5 @@ def eigen_symmetric(A, k=6, M=None, sigma=None, which='LM', v0=None,
         raise RuntimeError("Error info=%d in arpack"%info)
         return None
     if return_eigenvectors:
-        return d,np.asmatrix(z)
+        return d,z
     return d

commit 728a90b6c748864c0c05f187dfab7da5928968f3
Author: wnbell <wnbell@localhost>
Date:   Wed Feb 27 06:14:46 2008 +0000

    moved scipy.splinalg to scipy.sparse.linalg

diff --git a/scipy/sparse/linalg/eigen/arpack/arpack.py b/scipy/sparse/linalg/eigen/arpack/arpack.py
new file mode 100644
index 000000000..d227b8197
--- /dev/null
+++ b/scipy/sparse/linalg/eigen/arpack/arpack.py
@@ -0,0 +1,486 @@
+"""
+Find a few eigenvectors and eigenvalues of a matrix.
+
+
+Uses ARPACK: http://www.caam.rice.edu/software/ARPACK/
+
+"""
+# Wrapper implementation notes
+#
+# ARPACK Entry Points
+# -------------------
+# The entry points to ARPACK are 
+# - (s,d)seupd : single and double precision symmetric matrix
+# - (s,d,c,z)neupd: single,double,complex,double complex general matrix
+# This wrapper puts the *neupd (general matrix) interfaces in eigen() 
+# and the *seupd (symmetric matrix) in eigen_symmetric().  
+# There is no Hermetian complex/double complex interface.
+# To find eigenvalues of a Hermetian matrix you
+# must use eigen() and not eigen_symmetric()
+# It might be desirable to handle the Hermetian case differently
+# and, for example, return real eigenvalues. 
+
+# Number of eigenvalues returned and complex eigenvalues
+# ------------------------------------------------------
+# The ARPACK nonsymmetric real and double interface (s,d)naupd return
+# eigenvalues and eigenvectors in real (float,double) arrays.  
+# Since the eigenvalues and eigenvectors are, in general, complex
+# ARPACK puts the real and imaginary parts in consecutive entries
+# in real-valued arrays.   This wrapper puts the real entries
+# into complex data types and attempts to return the requested eigenvalues
+# and eigenvectors.  
+
+
+# Solver modes
+# ------------
+# ARPACK and handle shifted and shift-inverse computations
+# for eigenvalues by providing a shift (sigma) and a solver.
+# This is currently not implemented
+
+__docformat__ = "restructuredtext en"
+
+__all___=['eigen','eigen_symmetric']
+
+import warnings
+
+import _arpack
+import numpy as np
+from scipy.sparse.linalg.interface import aslinearoperator
+
+_type_conv = {'f':'s', 'd':'d', 'F':'c', 'D':'z'}
+_ndigits = {'f':5, 'd':12, 'F':5, 'D':12}
+
+
+def eigen(A, k=6, M=None, sigma=None, which='LM', v0=None,
+          ncv=None, maxiter=None, tol=0, 
+          return_eigenvectors=True):
+    """Find k eigenvalues and eigenvectors of the square matrix A.
+
+    Solves A * x[i] = w[i] * x[i], the standard eigenvalue problem for
+    w[i] eigenvalues with corresponding eigenvectors x[i].
+
+
+    Parameters
+    ----------
+    A : A : matrix, array, or object with matvec(x) method
+        An N x N matrix, array, or an object with matvec(x) method to perform
+        the matrix vector product A * x.  The sparse matrix formats
+        in scipy.sparse are appropriate for A.
+
+    k : integer
+        The number of eigenvalues and eigenvectors desired
+
+    Returns
+    -------
+    w : array
+        Array of k eigenvalues
+
+    v : array
+       An array of k eigenvectors 
+       The v[i] is the eigenvector corresponding to the eigenvector w[i]
+
+    Other Parameters
+    ----------------
+
+    M : matrix or array
+        (Not implemented)
+        A symmetric positive-definite matrix for the generalized
+        eigenvalue problem A * x = w * M * x
+
+    sigma : real or complex
+        (Not implemented)
+        Find eigenvalues near sigma.  Shift spectrum by sigma.
+
+    v0 : array
+        Starting vector for iteration.  
+
+    ncv : integer
+        The number of Lanczos vectors generated 
+        ncv must be greater than k; it is recommended that ncv > 2*k
+
+    which : string
+        Which k eigenvectors and eigenvalues to find:
+         - 'LM' : largest magnitude
+         - 'SM' : smallest magnitude
+         - 'LR' : largest real part
+         - 'SR' : smallest real part
+         - 'LI' : largest imaginary part
+         - 'SI' : smallest imaginary part
+
+    maxiter : integer 
+        Maximum number of Arnoldi update iterations allowed
+
+    tol : float
+        Relative accuracy for eigenvalues (stopping criterion)
+
+    return_eigenvectors : boolean
+        Return eigenvectors (True) in addition to eigenvalues
+
+    See Also
+    --------    
+    eigen_symmetric : eigenvalues and eigenvectors for symmetric matrix A
+
+    Notes
+    -----
+
+    Examples
+    --------
+
+    """
+    A = aslinearoperator(A)
+    if A.shape[0] != A.shape[1]:
+        raise ValueError('expected square matrix (shape=%s)' % shape)
+    n = A.shape[0]
+
+    # guess type
+    typ = A.dtype.char
+    if typ not in 'fdFD':
+        raise ValueError("matrix type must be 'f', 'd', 'F', or 'D'")
+
+    if M is not None:
+        raise NotImplementedError("generalized eigenproblem not supported yet")
+    if sigma is not None:
+        raise NotImplementedError("shifted eigenproblem not supported yet")
+
+
+    # some defaults
+    if ncv is None:
+        ncv=2*k+1
+    ncv=min(ncv,n)
+    if maxiter==None:
+        maxiter=n*10
+    # assign starting vector        
+    if v0 is not None:
+        resid=v0
+        info=1
+    else:
+        resid = np.zeros(n,typ)
+        info=0
+
+
+    # some sanity checks
+    if k <= 0:
+        raise ValueError("k must be positive, k=%d"%k)
+    if k == n:
+        raise ValueError("k must be less than rank(A), k=%d"%k)
+    if maxiter <= 0:
+        raise ValueError("maxiter must be positive, maxiter=%d"%maxiter)
+    whiches=['LM','SM','LR','SR','LI','SI']
+    if which not in whiches:
+        raise ValueError("which must be one of %s"%' '.join(whiches))
+    if ncv > n or ncv < k:
+        raise ValueError("ncv must be k<=ncv<=n, ncv=%s"%ncv)
+
+    # assign solver and postprocessor
+    ltr = _type_conv[typ]
+    eigsolver = _arpack.__dict__[ltr+'naupd']
+    eigextract = _arpack.__dict__[ltr+'neupd']
+
+    v = np.zeros((n,ncv),typ) # holds Ritz vectors
+    workd = np.zeros(3*n,typ) # workspace
+    workl = np.zeros(3*ncv*ncv+6*ncv,typ) # workspace
+    iparam = np.zeros(11,'int') # problem parameters
+    ipntr = np.zeros(14,'int') # pointers into workspaces
+    ido = 0
+
+    if typ in 'FD':
+        rwork = np.zeros(ncv,typ.lower())
+
+    # set solver mode and parameters
+    # only supported mode is 1: Ax=lx
+    ishfts = 1
+    mode1 = 1
+    bmat = 'I'
+    iparam[0] = ishfts
+    iparam[2] = maxiter
+    iparam[6] = mode1
+
+    while True:
+        if typ in 'fd':
+            ido,resid,v,iparam,ipntr,info =\
+                eigsolver(ido,bmat,which,k,tol,resid,v,iparam,ipntr,
+                          workd,workl,info)
+        else:
+            ido,resid,v,iparam,ipntr,info =\
+                eigsolver(ido,bmat,which,k,tol,resid,v,iparam,ipntr,
+                          workd,workl,rwork,info)
+
+        xslice = slice(ipntr[0]-1, ipntr[0]-1+n)
+        yslice = slice(ipntr[1]-1, ipntr[1]-1+n)
+        if ido == -1:
+            # initialization
+            workd[yslice]=A.matvec(workd[xslice])
+        elif ido == 1:
+            # compute y=Ax
+            workd[yslice]=A.matvec(workd[xslice])
+        else:
+            break
+
+    if  info < -1 :
+        raise RuntimeError("Error info=%d in arpack"%info)
+        return None
+    if info == -1:
+        warnings.warn("Maximum number of iterations taken: %s"%iparam[2])
+#    if iparam[3] != k:
+#        warnings.warn("Only %s eigenvalues converged"%iparam[3])
+
+
+    # now extract eigenvalues and (optionally) eigenvectors
+    rvec = return_eigenvectors
+    ierr = 0
+    howmny = 'A' # return all eigenvectors
+    sselect = np.zeros(ncv,'int') # unused
+    sigmai = 0.0 # no shifts, not implemented
+    sigmar = 0.0 # no shifts, not implemented
+    workev = np.zeros(3*ncv,typ)
+
+    if typ in 'fd':
+        dr=np.zeros(k+1,typ)
+        di=np.zeros(k+1,typ)
+        zr=np.zeros((n,k+1),typ)
+        dr,di,zr,info=\
+            eigextract(rvec,howmny,sselect,sigmar,sigmai,workev,
+                   bmat,which,k,tol,resid,v,iparam,ipntr,
+                   workd,workl,info)
+
+        # The ARPACK nonsymmetric real and double interface (s,d)naupd return
+        # eigenvalues and eigenvectors in real (float,double) arrays.  
+
+        # Build complex eigenvalues from real and imaginary parts
+        d=dr+1.0j*di
+
+        # Arrange the eigenvectors: complex eigenvectors are stored as 
+        # real,imaginary in consecutive columns
+        z=zr.astype(typ.upper())
+        eps=np.finfo(typ).eps
+        i=0
+        while i<=k:
+            # check if complex
+            if abs(d[i].imag)>eps:
+                # assume this is a complex conjugate pair with eigenvalues
+                # in consecutive columns
+                z[:,i]=zr[:,i]+1.0j*zr[:,i+1]
+                z[:,i+1]=z[:,i].conjugate()
+                i+=1
+            i+=1
+                      
+        # Now we have k+1 possible eigenvalues and eigenvectors
+        # Return the ones specified by the keyword "which"
+        nreturned=iparam[4] # number of good eigenvalues returned
+        if nreturned==k:    # we got exactly how many eigenvalues we wanted
+            d=d[:k]
+            z=z[:,:k]
+        else:   # we got one extra eigenvalue (likely a cc pair, but which?)
+            # cut at approx precision for sorting
+            rd=np.round(d,decimals=_ndigits[typ])
+            if which in ['LR','SR']:
+                ind=np.argsort(rd.real) 
+            elif which in ['LI','SI']:
+                # for LI,SI ARPACK returns largest,smallest abs(imaginary) why?
+                ind=np.argsort(abs(rd.imag)) 
+            else:
+                ind=np.argsort(abs(rd))
+            if which in ['LR','LM','LI']:
+                d=d[ind[-k:]]
+                z=z[:,ind[-k:]]
+            if which in ['SR','SM','SI']:
+                d=d[ind[:k]]
+                z=z[:,ind[:k]]
+
+
+    else:
+        # complex is so much simpler...
+        d,z,info =\
+              eigextract(rvec,howmny,sselect,sigmar,workev,
+                         bmat,which,k,tol,resid,v,iparam,ipntr,
+                         workd,workl,rwork,ierr)
+
+
+
+    if ierr != 0:
+        raise RuntimeError("Error info=%d in arpack"%info)
+        return None
+    if return_eigenvectors:
+        return d,np.asmatrix(z)
+    return d
+
+
+def eigen_symmetric(A, k=6, M=None, sigma=None, which='LM', v0=None,
+                    ncv=None, maxiter=None, tol=0, 
+                    return_eigenvectors=True):
+    """Find k eigenvalues and eigenvectors of the real symmetric 
+    square matrix A.
+
+    Solves A * x[i] = w[i] * x[i], the standard eigenvalue problem for
+    w[i] eigenvalues with corresponding eigenvectors x[i].
+
+
+    Parameters
+    ----------
+    A : matrix or array with real entries or object with matvec(x) method
+        An N x N real symmetric matrix or array or an object with matvec(x)
+        method to perform the matrix vector product A * x.  The sparse
+        matrix formats in scipy.sparse are appropriate for A.
+
+    k : integer
+        The number of eigenvalues and eigenvectors desired
+
+    Returns
+    -------
+    w : array
+        Array of k eigenvalues
+
+    v : array
+       An array of k eigenvectors 
+       The v[i] is the eigenvector corresponding to the eigenvector w[i]
+
+    Other Parameters
+    ----------------
+    M : matrix or array
+        (Not implemented)
+        A symmetric positive-definite matrix for the generalized
+        eigenvalue problem A * x = w * M * x
+
+
+    sigma : real
+        (Not implemented)
+        Find eigenvalues near sigma.  Shift spectrum by sigma.
+    
+    v0 : array
+        Starting vector for iteration.  
+
+    ncv : integer
+        The number of Lanczos vectors generated 
+        ncv must be greater than k; it is recommended that ncv > 2*k
+
+    which : string
+        Which k eigenvectors and eigenvalues to find:
+         - 'LA' : Largest (algebraic) eigenvalues
+         - 'SA' : Smallest (algebraic) eigenvalues
+         - 'LM' : Largest (in magnitude) eigenvalues
+         - 'SM' : Smallest (in magnitude) eigenvalues
+         - 'BE' : Half (k/2) from each end of the spectrum  
+                  When k is odd, return one more (k/2+1) from the high end
+
+    maxiter : integer 
+        Maximum number of Arnoldi update iterations allowed
+
+    tol : float
+        Relative accuracy for eigenvalues (stopping criterion)
+
+    return_eigenvectors : boolean
+        Return eigenvectors (True) in addition to eigenvalues
+
+    See Also
+    --------    
+    eigen : eigenvalues and eigenvectors for a general (nonsymmetric) matrix A
+
+    Notes
+    -----
+
+    Examples
+    --------
+    """
+    A = aslinearoperator(A)
+    if A.shape[0] != A.shape[1]:
+        raise ValueError('expected square matrix (shape=%s)' % shape)
+    n = A.shape[0]
+
+    # guess type
+    typ = A.dtype.char
+    if typ not in 'fd':
+        raise ValueError("matrix must be real valued (type must be 'f' or 'd')")
+
+    if M is not None:
+        raise NotImplementedError("generalized eigenproblem not supported yet")
+    if sigma is not None:
+        raise NotImplementedError("shifted eigenproblem not supported yet")
+
+    if ncv is None:
+        ncv=2*k+1
+    ncv=min(ncv,n)
+    if maxiter==None:
+        maxiter=n*10
+    # assign starting vector        
+    if v0 is not None:
+        resid=v0
+        info=1
+    else:
+        resid = np.zeros(n,typ)
+        info=0
+
+    # some sanity checks
+    if k <= 0:
+        raise ValueError("k must be positive, k=%d"%k)
+    if k == n:
+        raise ValueError("k must be less than rank(A), k=%d"%k)
+    if maxiter <= 0:
+        raise ValueError("maxiter must be positive, maxiter=%d"%maxiter)
+    whiches=['LM','SM','LA','SA','BE']
+    if which not in whiches:
+        raise ValueError("which must be one of %s"%' '.join(whiches))
+    if ncv > n or ncv < k:
+        raise ValueError("ncv must be k<=ncv<=n, ncv=%s"%ncv)
+
+    # assign solver and postprocessor
+    ltr = _type_conv[typ]
+    eigsolver = _arpack.__dict__[ltr+'saupd']
+    eigextract = _arpack.__dict__[ltr+'seupd']
+
+    # set output arrays, parameters, and workspace
+    v = np.zeros((n,ncv),typ)
+    workd = np.zeros(3*n,typ)
+    workl = np.zeros(ncv*(ncv+8),typ)
+    iparam = np.zeros(11,'int')
+    ipntr = np.zeros(11,'int')
+    ido = 0
+
+    # set solver mode and parameters
+    # only supported mode is 1: Ax=lx
+    ishfts = 1
+    mode1 = 1
+    bmat='I'
+    iparam[0] = ishfts
+    iparam[2] = maxiter
+    iparam[6] = mode1
+
+    while True:
+        ido,resid,v,iparam,ipntr,info =\
+            eigsolver(ido,bmat,which,k,tol,resid,v,
+                      iparam,ipntr,workd,workl,info)
+
+        xslice = slice(ipntr[0]-1, ipntr[0]-1+n)
+        yslice = slice(ipntr[1]-1, ipntr[1]-1+n)
+        if ido == -1:
+            # initialization
+            workd[yslice]=A.matvec(workd[xslice])
+        elif ido == 1:
+            # compute y=Ax
+            workd[yslice]=A.matvec(workd[xslice])
+        else:
+            break
+
+    if  info < -1 :
+        raise RuntimeError("Error info=%d in arpack"%info)
+        return None
+    if info == -1:
+        warnings.warn("Maximum number of iterations taken: %s"%iparam[2])
+
+    # now extract eigenvalues and (optionally) eigenvectors
+    rvec = return_eigenvectors
+    ierr = 0
+    howmny = 'A' # return all eigenvectors
+    sselect = np.zeros(ncv,'int') # unused
+    sigma = 0.0 # no shifts, not implemented
+
+    d,z,info =\
+             eigextract(rvec,howmny,sselect,sigma,
+                        bmat,which, k,tol,resid,v,iparam[0:7],ipntr,
+                        workd[0:2*n],workl,ierr)
+
+    if ierr != 0:
+        raise RuntimeError("Error info=%d in arpack"%info)
+        return None
+    if return_eigenvectors:
+        return d,np.asmatrix(z)
+    return d
